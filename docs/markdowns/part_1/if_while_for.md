# Условный оператор if. Операторы цикла while и for

## Условный оператор if

Случается так, что в зависимости от значения переменной необходимо сделать одно из запрограммированных действий. Другими словами, внутри программы может происходить **ветвление потока**.

### Оператор if

В Python **для ветвление потока выполнения программы используется оператор `if`**. Рассмотрим пример ниже.

```Python
x = 4

if x > 0:
    print("x больше нуля!")
```

Оператор `if` работает следующим образом. После `if` записывается условие, и если выражение истинно, то интерпретатор выполняет то, что написано _"под if"_ после отступа. В конце выражения в строке оператора `if` ставится двоеточие `:` _(означает "следующая строка с отступом")_. Данное условие выполнится тогда, когда значение x будет больше 0. В противном случае, в консоли не будет вывода функции `print()`.

```Python
x = -5

if x > 0:
    print("x больше нуля!")

# Вывода в консоли нет!
```

### Стиль по PEP-8

В Python, `PEP (Python Enhancement Proposal)` - это предложение по улучшению языка. PEP представляет собой документ, предлагающий изменение или дополнение к языку Python, который может включать новые синтаксисы, библиотеки или инструменты.
Когда авторы Python считают, что определенное изменение может улучшить язык, они пишут PEP. Затем PEP обсуждается и голосуется сообществом Python на предмет его принятия или отклонения.

`PEP8` - этот предложение по развитию Python, которе описывает соглашение о том, как правильно писать код. [Подробнее здесь!](https://peps.python.org/pep-0008/)

Одной из особенностей написания кода в Python является **отступы**. После операторов ставят отступы:

* Tab
* 4 пробела

**Отступы позволяют оградить выражения**, которые относятся к условию, от тех, которые к нему не относятся.

```Python
x = -1
if x > 0:
    print("x больше нуля!")  # выполнится, если условие сработает

result = 1                   # не относится к if
print(f"результат = {result}")  # этот код сработает
```

Если под условием _(и под другими операторами)_ записано несколько строк кода, то отступы формируются в **уровни**. На данном уровне отступа также можно записать новый оператор условия и перейти на новый уровень. Такое поведение называется **вложенностью**.

```Python
x = 1
if x == 0:
    print("x равен нулю!")
    if x > 0:
        print("x больше нуля")
```

**Обратите внимание**, что лишний пробел на уровне вложенность приводит к ошибке. По умолчанию, отступ содержит 4 пробела!

```Python
x = 4
if x > 0:
    print("x больше нуля")
     result = 1  # Синтаксическая ошибка
print(f"результат = {result}")
```

### Операторы сравнения и логический тип данных

Для работы оператора `if` нужно использовать выражения, которые отвечают **истинностью** или **ложностью**. Такие выражения используют операторы сравнения, список которые представлен ниже.

Оператор    | Значение
:--         | :--
\>          | больше
<           | меньше
\>=         | больше или равно
<=          | меньше или равно
==          | полное соответствие
!=          | не равно

Для примера рассмотрим следующую операцию. Узнаем какой будет результат.

```Python
print(2 > 2)  # False, так как строго больше
```

В результате получается тип данных `bool`, который может принимать одно из двух значений: **истина (True)** или **ложь (False)**.

В том случае, если условия **необходимо сгруппировать**, нужно использовать **логические операторы**.

Оператор    | Значение
:--         | :--
or          | или
and         | и
not         | не

Примеры использования рассмотрены ниже.

```Python
# and (оператор И)
# условие будет истинно, если оба операнда истины.
print(True and True)  # Ответ: True
print(True and False)  # Ответ: False

# or (оператор ИЛИ)
# если хотя бы один из операндов истинный, то результатом всего выражения будет True
print(True or False)  # Ответ: True
print(False and False)  # Ответ: False

# not (оператор НЕ)
# изменяет значение операнда на противоположное
print(not True)  # Ответ: False
```

Такая же логика работает и с выражениями сравнения. Запишем условие с `if`.

```Python
x, y, z = 2, 3, -1 

# простое условие
if y > x:
    print(f"{y} больше {x}.")


# условие с логическим оператором
if y > x and y == z:  # условие не выполняется!
    print(f"{y} больше {x} и равно {z}.")  

```

### Инструкция if-elif-else

Как быть, если условие под if не выполнено. Для обработки альтернативного условия используются операторы `elif` и `else`.

**Разберем пример.** Необходимо узнать, больше ли сумма заданной числовой последовательности порогового значения 285?

Числовые последовательности можно создавать с помощью функции `range()`. В качестве аргументов она принимает начальное значение, конечное значение и шаг, с которым нужно двигаться по последовательности. Например, чтобы создать последовательность от 0 до 9, нужно написать `range(0, 11)`, а чтобы получить последовательность от 10 до 100 с шагом 15, нужно написать `range(10, 100, 15)`.

```Python
# 1. Создадим числовую последовательность
# от 10 до 100 с шагом 15
primes = range(10, 100, 15)

# 2. Вычисляем его сумму с помощью функции sum()
res = sum(primes)

# 3. Необходимо узнать, больше полученная сумма пороговому значению 285?
num = 285
```

Используем `if-elif-else`.

* Если условие истинно, то работает выражение под оператором `if`.
* Если условие в if не выполняется, то будет проверено альтернативное условие в `elif`.
* В противном случае, если никакое из предложенных условий не выполняется, то работает оператор `else`.

```Python
if res > num:
    print(f'{res} больше {num}')
elif res < l:
    print(f'{res} меньше {num}')
else:
    print(f'{res} равен {num}')
```

## Операторы цикла

Операторы цикла в Python используются для выполнения блока кода определенное количество раз или до выполнения заданного условия. Они нужны для того, чтобы выполнять однотипные действия многократно. 

Вот наиболее распространенные виды циклов в Python:

* `for` используется для итерации по каждому элементу в коллекции.
* `while` выполняется пока заданное условие остается истинным.

### Оператор while

Оператор `while` позволяет многократно выполнять код в зависимости от заданного логического условия.

Рассмотрим простой пример. Представим, что нам необходимо вывести на экран текущее значение счетчика `i`, пока значение не будет больше 10. Чтобы не писать каждый раз функцию `print()` с новым значением `i`, можно упростить код и использовать цикл `while`, записав условие **"пока `i` меньше либо равен 10"** и указав операция под этим условием.

```Python
i = 1                  # i хранит 1 (int)

while i <= 10:         # до тех пор, пока i < 10:
    i = i + 1              # добавлять к i единицу,
    print('i =', i)        # выводить полученный i.

print('До свидания!')  # до свидания!
```

**Для чего нужна операция `i = i + 1`?**

Рассмотрим по шагам, как блок кода выше будет выполнятся без этой строки.

1. `i` принял значение 1.
2. проверяем условие у while: `i <= 10` -> **Истина**.
3. входим в условие и выполняем функцию `print('i =', i)`.
4. в консоли появляется сообщение `i = 1`.
5. возвращаемся в условие цикла while `i <= 10`
6. **так как `i = 1`, то в условии опять будет проверен тот же `i`. И так будет продолжаться вечно!**

```Python
i = 1 

while i <= 10:
    print('i =', i)

# ОШИБКА ВЕЧНОГО ЦИКЛА!
# Чтобы остановить работу интерпретатора,
# нажмите Ctrl + C
```

Поэтому, если вы используете цикл с `while`, **не забывайте делать шаг в счетчике, от которого зависит движение цикла**!

Прибавление единицы к самой переменной `i` довольно частая операция. Поэтому существуют сокращенные записи такой операции, которая записывается с помощью оператора `+=`. Также существуют `-=` и `*=`.

```Python
i = 1 

while i <= 10:
    i += 1  # тоже самое, что i = i + 1
    print('i =', i)

print('До свидания!')
```

Оператор `if` также можно записывать внутри циклов. Рассмотрим пример. Пользователь вводит с консоли число с помощью функции `input()`. Если он попадает в интервал от 1 до 5, то в консоли выводится сообщение _'Вы выиграли!'_.

```Python
i = 0
user_input = int(input('Введите число: '))

while i < 5:
    if i == user_input:
        print('Вы выиграли!')
    print(i)
    i += 1 
```

Обратите внимание на операцию приведения к типу `int()` перед input, так как результат функции input - это `str`, а **сравнивать `int` можно только с `int`**.

В примере выше выполнение цикла не останавливается, когда выполняется условие. Оператор `break` позволяет прервать циклы, когда условие выполнится. **break можно использовать только внутри циклов!**

```Python
i = 0
user_input = int(input('Введите число: '))

while i < 5:
    if i == user_input:
        print('Вы выиграли!')
        break  # break - прекращает цикл
    print(i)
    i += 1
```

Операторы инструкции `if-elif-else` можно вводить на разных уровнях. Например, когда цикл завершит работу и условие `if` внутри не будет выполнено, то **после цикла сработает оператор `else`**.

```Python
i = 0
user_input = int(input('Введите число: '))

while i < 5:
    if i == user_input:
        print('Вы выиграли!')
        break
    print(i)
    i += 1

else:
    print('Вы проиграли!')
```

### Оператор for

Зачастую необходимо выполнять операции над элементами коллекции. Чтобы получить каждый элемент последовательно, нужно знать индекс каждого элемента коллекции. Такую задачу можно выполнить с помощью цикла `while` в следующем примере.

Чтобы узнать длину строки, списка или кортежа, можно воспользоваться функцией `len()`.

```Python
# Вернемся к исходной числовой последовательности
primes = range(10, 100, 15)
i = 0  # первый индекс 0

while i < len(primes): # пока индекс i меньше длины primes
    print(primes[i])  # вывод элемента списка по индексу
    i += 1
```

Есть ряд трудностей с применением цикла `while` для списков:

1. нужно четко отслеживать изменения текущего индекса,
2. индекс не должен перейти длину списка во избежании ошибки `Index out of range`.

Оператор `for` позволяет перебирать все элементы строк, списков, кортежей и других коллекций с помощью заданной переменной.

```Python
primes = range(10, 100, 15)

for i in primes:  # для каждого i из primes
    print(i)
```

Обратите внимание, что в данном случае **`i` будет хранить элемент списка, а не индекс**.

Рассмотрим применение цикла `for` для строки. Необходимо вытащить все цифры из заданной строки. Каждый элемент можно проверить с помощью метода строки `isdigit()`, является ли он числом.

Оператор `pass` пропускает какие-либо действия. Также еще существует оператор continue, о применении которого можно прочитать [по ссылке](https://www.digitalocean.com/community/tutorials/how-to-use-break-continue-and-pass-statements-when-working-with-loops-in-python-3).

```Python
s = "Дата заказа:2018-10-14"
new_s= '' # создадим строку

for i in s:
    if i.isdigit() == True: # является ли символ цифрой
        new_s += i # добавить символ строку
    else:
        pass # пропустить символ
```

С помощью оператора `for` можно **получать** как **элементы списка**, так и **индексы элементов**. В примерах ниже рассмотрены варианты их получения для последовательности `primes`.

```Python
primes = range(10, 100, 15)

# Вариант 1 - возврат элементов
for i in primes:
  print(i)

# Вариант 2 - возврат элементов с помощью индексов
for i in range(len(shop_list)):
  print(i, shop_list[i])
```

Запись варианта 2 выглядит довольно громоздко. Поэтому в Python существует функция `enumerate()`, которая возвращает кортежи-пары индексов и элементов. Функция enumerate() является "ленивой" и возвращает результата только тогда, когда ее перебирают в цикле или превращают в коллекцию.

```Python
# Вариант 3 - возврат индексов и элементов 
for i, item in enumerate(shop_list):
  print(i, item)
```

## Дополнения к операторам

### Инструкция try-except

В Python инструкция `try-except` используется для обработки ошибок в коде. Она позволяет выполнить блок кода, который может вызвать исключение, и избежать аварийного завершения программы.  

**Исключения** — это ошибки, которые могут возникнуть во время выполнения программы. Они могут быть результатом деления на ноль, обращения к несуществующему элементу списка и т.д.

```Python
x = 5
y = 0

print(f"Результат: {x/y}") # Ошибка ZeroDivisionError
```

В примере ниже показан пример, в котором необходимо обработать ошибку деления на ноль.

```Python
x = 5
y = 0

try:  # сначала код выполняется здесь
    print(f"Результат: {x/y}")
except ZeroDivisionError: # если в try ошибка, то код выполняется здесь
    print('На 0 делить нельзя!')
```

Операторы `try` и `except` являются обязательными частями инструкции, `else` и `finally` - опциональными.

```Python
x = 5
y = 1  # изменили y

try:
    print(f"Результат: {x/y}")
except ZeroDivisionError:
    print('На 0 делить нельзя!')
else: # выполняется в том случае, если не было исключения
    print(f"Следующий результат: {x*2}")
finally: # выполняется в любом случае, независимо отработал ли блок try или except
    print(f"Результат: {x}")
```

Подробнее про применение try-except мы рассмотрим во второй части курса.

### Инструкция match-case

В Python оператор `match-case` используется для выбора одного из нескольких блоков кода для выполнения в зависимости от условия. Инструкция аналогична `if-elif-else` - позволяет работать со сложными условиями, но имеет более структурированный и читаемый вид.

Ниже приведен пример, в котором с консоли вводится число и в случае, если val = 1, то получаем ответ "Добрый день", если 2, то "Добрый вечер" и так и далее, в зависимости от значения переменной val.

```Python
val = int(input("Введите число: "))

match val:
    case 1:
        print ("Добрый утро🌁")
    case 2:
        print ("Добрый день🏙️")
    case 3:
        print ("Доброе вечер🌆")
    case _:  # если такого шаблона нет
        print ("Случайное значение❓")
```

Подробнее про применение match-case мы рассмотрим во второй части курса.

**Промежуточный итог и справка по вопросам**

Теперь вы знаете, как работают различные вспомогательные операторы: для создания ветвления и циклов, для обработки ошибок и шаблонов. Следующие параграфы посвящены вопросам по теме. Постарайтесь ответить на предложенные вопросы **сначала самостоятельно, потом перейти к объяснениям**. В объяснениях будет рассмотрен подробнее новый материал, поэтому обязательно изучите их.

## Вопросы по теме

### Вопрос 1

Каким будет результат выполнения кода ниже?

```Python
value = 0
if value > 0:
    print('> 0')
elif:
    print('<= 0')

# > 0
# <= 0
# None
# Error
```

### Вопрос 2

Каким будет результат выполнения кода ниже?

```Python
fvar = 1 == 1 or 1 != 1
svar = fvar == 1 and 2 != 2.0

if (svar):
    print(svar)
else:
    print(fvar)

# True
# False
# 1
# 0
```

### Вопрос 3

Каким будет результат выполнения кода ниже?

```Python
fvar = 0
svar = 1
if fvar == True and svar == False:
    print('True')
else:
    print('False')

# 'True'
# 'False'
# 1
# 0
```

### Вопрос 4

Каким будет результат выполнения кода ниже?

```Python
var = 0

while var <= 10:
    var += 2
    if var % 4 == 0:
        print(var)

# 0 4 8
# 4 8
# 4 8 12
# Error
```

### Вопрос 5

Каким будет результат выполнения кода ниже?

```Python
lst = [10, 15, 20]

for i in lst:
    if i % 2:
        lst.append(i)

print(lst)

# [15, 15, 15]
# [10, 15, 20, 15]
# Infinite loop
# Error
```

### Вопрос 6

Каким будет результат выполнения кода ниже?

```Python
lst = ["я", "нена...люблю", "Python"]

for i in lst:
    i.capitalize()

print(lst)

# ["я", "нена...люблю", "Python"]
# ["Я", "НЕНА...ЛЮБЛЮ", "PYTHON"]
# ["Я", "Нена...люблю", "Python"]
# Error
```

### Вопрос 7

Каким будет результат выполнения кода ниже?

```Python
lst = []

for i in "abc":
    for j in range(2):
        lst.append([i, j])

print(lst)

# [['a', 0], ['b', 1]]
# [['a', 0], ['b', 1], ['c', 1]]
# [['a', 0], ['a', 1], ['b', 0], ['b', 1], ['c', 0], ['c', 1]]
# Error
```

## Ответы на вопросы и пояснения

### Ответ на вопрос 1

Каким будет результат выполнения кода ниже?

```Python
value = 0
if value > 0:
    print('> 0')
elif:
    print('<= 0')

# > 0
# <= 0
# None
# Error  <- правильно
```

**Обратите внимание!**

Условный оператор `elif` обязательно должен содержать условие. Когда такового нет, используется `else`. Если не придерживаться этого простого правила, то мы будем получать `SyntaxError`, как в этой задаче.

### Ответ на вопрос 2

Каким будет результат выполнения кода ниже?

```Python
fvar = 1 == 1 or 1 != 1
svar = fvar == 1 and 2 != 2.0

if (svar):
    print(svar)
else:
    print(fvar)

# True  <- правильно
# False
# 1
# 0
```

**Обратите внимание!**

В данном случае `fvar` и `svar` — переменные типа boolean. А потому ответ будет True либо False.
`fvar = True`, т.к. 1 == 1 — True, чего уже достаточно в выражении `1 == 1 or 1 != 1`.

`svar = False`, т.к. в выражении `fvar == 1 and 2 != 2.0` есть False, а именно последнее. Да, 2 == 2.0, а не наоборот.

В итоге условие в `if` не выполняется, а потому в печать уходит значение `fvar`.

### Ответ на вопрос 3

Каким будет результат выполнения кода ниже?

```Python
fvar = 0
svar = 1
if fvar == True and svar == False:
    print('True')
else:
    print('False')

# 'True'
# 'False'  <- правильно
# 1
# 0
```

**Обратите внимание!**

Получаем в if следующее выражение: `if 0 == True and 1 == False`.  Оно ложно, так как **True может быть равен всему, но не нулю, а False всегда равен нулю**. Потому печатается то, что написано в else, т.е. `'False'`.

### Ответ на вопрос 4

Каким будет результат выполнения кода ниже?

```Python
var = 0

while var <= 10:
    var += 2
    if var % 4 == 0:
        print(var)

# 0 4 8
# 4 8
# 4 8 12  <- правильно
# Error
```

**Обратите внимание!**

Так как в while условие `var <= 10`, то функция заходит в тело цикла в последние раз со значением `var = 10`. Затем это значение увеличивается до 12 и, удовлетворяя условию `var % 4 == 0`, на выходе получаем то, что напечатается и число 12.

### Ответ на вопрос 5

Каким будет результат выполнения кода ниже?

```Python
lst = [10, 15, 20]

for i in lst:
    if i % 2:
        lst.append(i)

print(lst)

# [15, 15, 15]
# [10, 15, 20, 15]
# Infinite loop  <- правильно
# Error
```

**Обратите внимание!**

Мы столкнулись с бесконечным циклом `(infinite loop)`, т.к. каждый раз, встречая нечётный элемент `lst`, мы добавляем в конец списка его же с помощью `append()`. В результате, это будет продолжаться бесконечно, т.к. данный нечётный элемент возникает постоянно.

### Ответ на вопрос 6

Каким будет результат выполнения кода ниже?

```Python
lst = ["я", "нена...люблю", "Python"]

for i in lst:
    i.capitalize()

print(lst)

# ["я", "нена...люблю", "Python"]  <- правильно
# ["Я", "НЕНА...ЛЮБЛЮ", "PYTHON"]
# ["Я", "Нена...люблю", "Python"]
# Error
```

**Обратите внимание!**

Метод `capitalize()` не изменяет строку на месте. Она лишь возвращает новую строку, значение которой нужно вручную где-то сохранить.

### Ответ на вопрос 7

Каким будет результат выполнения кода ниже?

```Python
lst = []

for i in "abc":
    for j in range(2):
        lst.append([i, j])

print(lst)

# [['a', 0], ['b', 1]]
# [['a', 0], ['b', 1], ['c', 1]]
# [['a', 0], ['a', 1], ['b', 0], ['b', 1], ['c', 0], ['c', 1]]  <- правильно
# Error
```

**Обратите внимание!**

В первом цикле мы будем перебирать три значения: `i = "a"`, `i = "b"`, `i = "c"`.

В следующем мы добавляем в конец `lst` список из `i` и `j`. Только после того, как **второй цикл с j закончит работу, интерпретатор перейдет к следующему символу в первом цикле**.
